<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WebSocket原理]]></title>
    <url>%2FMyBlogs%2F2016%2F03%2F01%2FWebSocket%2F</url>
    <content type="text"><![CDATA[WebSocket是HTML5出的东西（协议） 也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算） 首先HTTP有1.1和1.0之说，也就是所谓的keep-alive，把多个HTTP请求合并为一个，但是Websocket其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解 &lt;img src=”https://pic1.zhimg.com/6651f2f811ec133b0e6d7e6d0e194b4c_b.jpg“ data-rawwidth=”374” data-rawheight=”133” class=”content_image” width=”374”&gt; 有交集，但是并不是全部。 另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。。 通俗来说，你可以用HTTP协议传输非Html数据，就是这样=。=再简单来说，层级不一样。 Websocket是什么样的协议，具体有什么优点 首先，Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。 简单的举个例子吧，用目前应用比较广泛的PHP生命周期来解释。 HTTP的生命周期通过Request来界定，也就是一个Request 一个Response，那么在HTTP1.0中，这次HTTP请求就结束了。 在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。但是请记住 Request = Response 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。 教练，你BB了这么多，跟Websocket有什么关系呢？ 好吧，我正准备说Websocket呢。。 首先Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手。在握手阶段是一样的 以下涉及专业技术内容，不想看的可以跳过lol:，或者只看加黑内容——–首先我们来看个典型的Websocket握手（借用Wikipedia的。。） 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 熟悉HTTP的童鞋可能发现了，这段类似HTTP协议的握手请求中，多了几个东西。我会顺便讲解下作用。 12Upgrade: websocketConnection: Upgrade 这个就是Websocket的核心了，告诉Apache、Nginx等服务器：注意啦，窝发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。 123Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13 首先，Sec-WebSocket-Key 是一个Base64 encode的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠窝，我要验证尼是不是真的是Websocket助理。 然后，Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。简单理解：今晚我要服务A，别搞错啦~ 最后，Sec-WebSocket-Version 是告诉服务器所使用的Websocket Draft（协议版本） 在最初的时候，Websocket协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么Firefox和Chrome用的不是一个版本之类的，当初Websocket协议太多可是一个大难题。。 不过现在还好，已经定下来啦~大家都使用的一个东西~ 脱水：服务员，我要的是13岁的噢→_→ 然后服务器会返回下列东西，表示已经接受到请求， 成功建立Websocket啦！ 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: 这里开始就是HTTP最后负责的区域了，告诉客户，我已经成功切换协议啦~ 12Upgrade: websocketConnection: Upgrade 依然是固定的，告诉客户端即将升级的是Websocket协议，而不是mozillasocket，lurnarsocket或者shitsocket。 然后，Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key。服务器：好啦好啦，知道啦，给你看我的ID CARD来证明行了吧。。 后面的，Sec-WebSocket-Protocol 则是表示最终使用的协议。 至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。具体的协议就不在这阐述了。——————技术解析部分完毕—————— &lt;img src=”https://pic2.zhimg.com/afe119b52e096016139edabc2dfa9661_b.jpg“ data-rawwidth=”161” data-rawheight=”187” class=”content_image” width=”161”&gt; 你TMD又BBB了这么久，那到底Websocket有什么鬼用，http long poll，或者ajax轮询不都可以实现实时信息传递么。你TMD又BBB了这么久，那到底Websocket有什么鬼用，http long poll，或者ajax轮询不都可以实现实时信息传递么。 &lt;img src=”https://pic1.zhimg.com/20110e661edb1e93755a99c1d826e264_b.jpg“ data-rawwidth=”176” data-rawheight=”193” class=”content_image” width=”176”&gt; 好好好，年轻人，那我们来讲一讲Websocket有什么用。来给你吃点胡（苏）萝（丹）卜（红） &lt;img src=”https://pic4.zhimg.com/31ddf0cfbeecef21568d85ca60b5f1ff_b.jpg“ data-rawwidth=”53” data-rawheight=”65” class=”content_image” width=”53”&gt; 三、Websocket的作用在讲Websocket之前，我就顺带着讲下 long poll 和 ajax轮询 的原理。 首先是 ajax轮询 ，ajax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。 场景再现：客户端：啦啦啦，有没有新信息(Request) 服务端：没有（Response） 客户端：啦啦啦，有没有新信息(Request) 服务端：没有。。（Response） 客户端：啦啦啦，有没有新信息(Request) 服务端：你好烦啊，没有啊。。（Response） 客户端：啦啦啦，有没有新消息（Request） 服务端：好啦好啦，有啦给你。（Response） 客户端：啦啦啦，有没有新消息（Request） 服务端：。。。。。没。。。。没。。。没有（Response） —- loop long poll long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。 场景再现 客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） 服务端：额。。 等待到有消息的时候。。来 给你（Response） 客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop 从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。 何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。 简单地说就是，服务器是一个很懒的冰箱（这是个梗）（不会、不能主动发起连接），但是上司有命令，如果有客户来，不管多么累都要好好接待。 说完这个，我们再来说一说上面的缺陷（原谅我废话这么多吧OAQ） 从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。 ajax轮询 需要服务器有很快的处理速度和资源。（速度） long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小） 所以ajax轮询 和long poll 都有可能发生这种情况。 客户端：啦啦啦啦，有新信息么？ 服务端：月线正忙，请稍后再试（503 Server Unavailable） 客户端：。。。。好吧，啦啦啦，有新信息么？ 服务端：月线正忙，请稍后再试（503 Server Unavailable） 客户端： &lt;img src=”https://pic1.zhimg.com/7c0cf075c7ee4cc6cf52f4572a4c1c10_b.jpg“ data-rawwidth=”143” data-rawheight=”50” class=”content_image” width=”143”&gt; 然后服务端在一旁忙的要死：冰箱，我要更多的冰箱！更多。。更多。。（我错了。。这又是梗。。） 言归正传，我们来说Websocket吧通过上面这个例子，我们可以看出，这两种方式都不是最好的方式，需要很多资源。 一种需要更快的速度，一种需要更多的’电话’。这两种都会导致’电话’的需求越来越高。 哦对了，忘记说了HTTP还是一个无状态协议，通俗的说就是，服务器因为每天要接待太多客户了，是个健忘鬼，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。你第二次还得再告诉服务器一遍。 所以在这种情况下出现了，Websocket出现了。 他解决了HTTP的这几个难题。 首先，被动性，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。 所以上面的情景可以做如下修改。 客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：17（HTTP Request） 服务端：ok，确认，已升级为Websocket协议（HTTP Protocols Switched） 客户端：麻烦你有信息的时候推送给我噢。。 服务端：ok，有的时候会告诉你的。 服务端：balabalabalabala 服务端：balabalabalabala 服务端：哈哈哈哈哈啊哈哈哈哈 服务端：笑死我了哈哈哈哈哈哈哈 就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你）这样的协议解决了上面同步有延迟，而且还非常消耗资源的这种情况。 那么为什么他会解决服务器上消耗资源的问题呢？ 其实我们所用的程序是要经过两层代理的，即HTTP协议在Nginx等服务器的解析下，然后再传送给相应的Handler（PHP等）来处理。 简单地说，我们有一个非常快速的接线员（Nginx），他负责把问题转交给相应的客服（Handler）。 本身接线员基本上速度是足够的，但是每次都卡在客服（Handler）了，老有客服处理速度太慢，导致客服不够。 Websocket就解决了这样一个难题，建立后，可以直接跟接线员建立持久连接，有信息的时候客服想办法通知接线员，然后接线员在统一转交给客户。 这样就可以解决客服处理速度过慢的问题了。 同时，在传统的方式上，要不断的建立，关闭HTTP协议，由于HTTP是非状态性的，每次都要重新传输identity info（鉴别信息），来告诉服务端你是谁。 虽然接线员很快速，但是每次都要听这么一堆，效率也会有所下降的，同时还得不断把这些信息转交给客服，不但浪费客服的处理时间，而且还会在网路传输中消耗过多的流量/时间。 但是Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。 同时由客户主动询问，转换为服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。），没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的客服（Handler）了 至于怎么在不支持Websocket的客户端上使用Websocket。。答案是：不能 但是可以通过上面说的 long poll 和 ajax 轮询来 模拟出类似的效果 作者：Ovear链接：https://www.zhihu.com/question/20215561/answer/40316953来源：知乎]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack与Gulp]]></title>
    <url>%2FMyBlogs%2F2016%2F02%2F14%2Fwebpack%E4%B8%8Egulp%2F</url>
    <content type="text"><![CDATA[Webpack什么是Webpack WebPack可以看做是模块打包机 它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 为什么要使用它 如今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法 模块化，让我们可以把复杂的程序细化为小的文件; 类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能能装换为JavaScript文件使浏览器可以识别； scss，less等CSS预处理器 优点 模块化是Webpack最大的特点 你可以将一个网页模块化的拆分 Webpack会自己将你的代码打包在部署。 Gulp什么是Gulp Gulp是一种能够优化前端的开发流程的工具 为什么要使用它 管理JavaScript和CSS的顺序问题，而构建工具可以大大减少此类问题。 性能优化文件合并 浏览器需要下载多个JS文件，而浏览器是有并发限制，也就是同时并发只能下载几个文件，假如浏览器并发数是5，你有20个JS文件，而每5个需要2S, 那么你光下载JS文件都需要8S，那么网页的性能可想而知，所以我们需要合并多个文件以减少文件的数量。 文件压缩 我们知道文件越大，下载越慢，而针对JavaScript和CSS, 里面的空格，换行这些都是为了让我们读代码时更容易阅读，但是对机器来说，这些对它没有影响，所以为了减少文件大小，一般的情况我们都会用工具去掉空格和换行，有时候我们还会用比较短的变量名(记住这个要让工具最后压缩时做，而源代码一定要保证命名可读性) 来减少文件大小。 而所有的前端构建工具都具有文件合并和压缩的功能。 效率提升Vendor前缀 在CSS3使用越来越多的时候，我们都知道一些CSS的特性，不同的浏览器CSS有不同的前缀，如果我们手工添加将会很繁琐，而如果使用构建工具，很多构建工具可以自动给我添加CSS的Vendor前缀 单元测试 JavaScript的单元测试在使用MVC或者MVVM的框架后，变得越来越容易，而单元测试是质量保证的一个很重要的手段，所以在提交之前，使用构建工具自动跑一遍我们的单元测试是非常重要的 代码分析 我们写的JavaScript很多时候会有一些潜在的bug, 比如忘了添加分号，某个变量没有等等，使用一些JavaScript的代码分析工具，可以很好的帮我们检查一些常见的问题。 HTML引用JavaScript或者CSS文件 比如我们需要使用Bower之类来引用前端JavaScript和CSS的第三方库，那么如果版本升级，添加移除等都用手工来修改HTML的话，第一比较耗时，第二比较容易疏漏，尤其是在我们需要切换Debug和production版本时将会有很多额外的工作，那么使用前端构建工具可以很好的解决这些问题。 WebPack和Grunt相比有什么特性 其实Webpack和另外两个并没有太多的可比性，Gulp是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。 Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。 Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
        <tag>JS</tag>
        <tag>Webpack</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码压缩]]></title>
    <url>%2FMyBlogs%2F2015%2F11%2F18%2F%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[什么是代码压缩 Web性能优化最佳实践中最重要的一条是减少HTTP请求。而减少HTTP请求的最主要的方式就是，合并并压缩JavaScript和CSS文件。 关于编写css时，我们应注意通过一些细节来控制css文件的大小，比如：全局样式、继承样式、缩写样式，空格、注释等。 同时你也可以通过在线工具对你的css文件进行压缩，来减少css文件的大小，但压缩后的css文件在可维护性、识别性方面变的特别弱。 但更复杂的情况是，如果你的页面里面引用了多个css、多个js文件时就可能处理不好。 代码压缩的几大好处： 页面加载的时候只请求程序合并压缩后的c.css文件，这就减少了http对css文件的请求次数！ 不用对a.css和b.css进行压缩，保持了a.css和b.css的易编辑性、易识别性。 压缩：删除Javascript代码中所有的注释、跳转符号、换行符号及无用的空格，从而压缩了JS文件的大小。 混淆：经过编码将变量和函数原命名改为毫无意思的命名，以防他人窥视和窃取源代码。 这样做的几大坏处： 你需要解压工具才能打开文件。 如果压缩文件有损坏的话，可能是整个文件都受影响。 压缩的时候必须要注意以下几点： 压缩前的代码格式要标准。因为去掉换行与空格时，所有语句就变成一行了，如果你的代码有瑕疵（比如某行少了个分号），那就会导致整个文件报错。当然，现在有的压缩工具已经比较智能了。 备份原文件 压缩很可能不会一次成功，一般要多试，多改 工具 webpack gulp]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS精灵]]></title>
    <url>%2FMyBlogs%2F2015%2F08%2F11%2Fcss%E7%B2%BE%E7%81%B5%2F</url>
    <content type="text"><![CDATA[什么是CSS精灵 CSS Sprites在国内很多人叫css 精灵，是一种网页图片应用处理方式。 就是把网页中一些背景图片整合到一张图片文件中。 利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。 这样处理图片后，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。 将图片整合之后只需要加载一张或几张图片，就可以渲染浏览器内的大部分小图片。 CSS Sprites 的优点： 减少图片的字节 减少了网页的http请求，从而大大的提高了页面的性能3 .解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名，从而提高了网页的制作效率。4 .更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。维护起来更加方便。 CSS Sprites 的缺点： 在图片合并的时候，你要把多张图片有序的合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景；这些还好，最痛苦的是在宽屏，高分辨率的屏幕下的自适应页面，你的图片如果不够宽，很容易出现背景断裂； CSS Sprites在维护的时候比较麻烦，如果页面背景有少许改动，一般就要改这张合并的图片，无需改的地方最好不要动，这样避免改动更多的css，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动css。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解BFC和Margin Collapse]]></title>
    <url>%2FMyBlogs%2F2015%2F07%2F08%2FBFC%2F</url>
    <content type="text"><![CDATA[什么是BFC（Block formatting contexts）首先我们来看看w3c规范对BFC的解释，其实对于这种概念的学习上，我们总是建议首先寻找官方的定义，因为原则上来说官方的才是最权威和正确的，而且还比较详细，千万不要因为看到英文就畏惧不前。 w3c规范中的BFC定义：浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。 在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。 在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。 BFC的通俗理解：首先BFC是一个名词，是一个独立的布局环境，我们可以理解为一个箱子（实际上是看不见摸不着的），箱子里面物品的摆放是不受外界的影响的。转换为BFC的理解则是：BFC中的元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响。）并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 BFC的运用在w3c的规范中，除了上面的一段定义之外，BFC的相关知识点分布地比较零散，但基本集中在float、绝对定位、margin collaspe中。下面我们来看看如何应用到BFC来解决问题。 在很多网站中，我们经常会看到这样的一种，左边图片+右边信息的两栏结构，下面我们来看看如何利用BFC来实现。 首先我们给出这样的结构： 123456789//CSS.box &#123;width:210px;border: 1px solid #000;float: left;&#125;.img &#123;width: 100px;height: 100px;background: #696;float: left;&#125;.info &#123;background: #ccc;color: #fff;&#125;//HTML&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;image&lt;/div&gt; &lt;p class=&quot;info&quot;&gt;信息信息信息信息信息信息信息信息信息信息信息信&lt;/p&gt;&lt;/div&gt; 一般情况下它呈现出我们所乐意看到的样子： 但随着文字信息增多后，会变地非常的糟糕： 很明显，这是因为info类里面的文字受到了浮动元素的影响，但这并不是我们所期望的。此时我们可以为P元素的内容建立一个BFC，让其内容消除对外界浮动元素的影响。根据上文所知，只要给info元素添加overflow:hidden;即可为其内容建立新的BFC。当然你也可以通过其他方法来建立。其效果如下： 合并外边距与BFC在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠的结果： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 产生折叠的必备条件：margin必须是邻接的!而根据w3c规范，两个margin是邻接的必须满足以下条件： 必须是处于常规文档流（非float和绝对定位）的块级盒子,并且处于同一个BFC当中。 没有线盒，没有空隙（clearance，下面会讲到），没有padding和border将他们分隔开 都属于垂直方向上相邻的外边距，可以是下面任意一种情况 元素的margin-top与其第一个常规文档流的子元素的margin-top 元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom 高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottom 以上的条件意味着下列的规则： 创建了新的BFC的元素（例如浮动元素或者’overflow’值为’visible’以外的元素）与它的子元素的外边距不会折叠 浮动元素不与任何元素的外边距产生折叠（包括其父元素和子元素） 绝对定位元素不与任何元素的外边距产生折叠 inline-block元素不与任何元素的外边距产生折叠 一个常规文档流元素的margin-bottom与它下一个常规文档流的兄弟元素的margin-top会产生折叠，除非它们之间存在间隙（clearance）。 一个常规文档流元素的margin-top 与其第一个常规文档流的子元素的margin-top产生折叠，条件为父元素不包含 padding 和 border ，子元素不包含 clearance。 一个 ‘height’ 为 ‘auto’ 并且 ‘min-height’ 为 ‘0’的常规文档流元素的 margin-bottom 会与其最后一个常规文档流子元素的 margin-bottom 折叠，条件为父元素不包含 padding 和 border ，子元素的 margin-bottom 不与包含 clearance 的 margin-top 折叠。 一个不包含border-top、border-bottom、padding-top、padding-bottom的常规文档流元素，并且其 ‘height’ 为 0 或 ‘auto’， ‘min-height’ 为 ‘0’，其里面也不包含行盒(line box)，其自身的 margin-top 和 margin-bottom 会折叠。（下面我们对不产生折叠的情况逐一分析。） 浮动和绝对定位不与任何元素产生 margin 折叠原因：浮动元素和绝对定位元素不与其他盒子产生外边距折叠是因为元素会脱离当前的文档流，违反了上面所述的两个margin是邻接的条件同时，又因为浮动和绝对定位会使元素为它的内容创建新的BFC，因此该元素和子元素所处的BFC是不相同的，因此也不会产生margin的折叠。 DEMO： 12345678910111213141516171819202122//CSSbody &#123;padding:0;margin: 0; text-align: center;&#125;.wrapper &#123;margin:30px;width: 450px;border:1px solid red;&#125;.small-box &#123;width: 50px;height: 50px;margin: 10px;background: #9cc;&#125;.middle-box &#123;width: 100px;height: 100px;margin: 20px;background: #99c;&#125;.big-box &#123;width: 120px;height: 120px;margin: 20px;background: #33e;&#125;.floatL &#123;float: left;&#125;.floatR &#123;float: right;&#125;.clear &#123;clear: both;&#125;.posA &#123;position: absolute;&#125;.overHid&#123;overflow: hidden;&#125;.red &#123;background: #f00;&#125;.green &#123;background: #0f0;&#125;.blue &#123;background: #00f;&#125;//HTML&lt;div class=&quot;wrapper overHid&quot;&gt; &lt;div class=&quot;big-box blue&quot;&gt;non-float&lt;/div&gt; &lt;div class=&quot;middle-box green floatL&quot;&gt; &lt;div class=&quot;small-box red&quot;&gt;&lt;/div&gt; float left &lt;/div&gt;&lt;/div&gt; 但是浮动元素脱离了当前的BFC并不影响它后面的兄弟元素，后面的兄弟元素与浮动元素前面的元素依然在同一个BFC当中，所以，它们之间的margin还是会折叠的。下面我们对上面的demo做一下修改： 12345&lt;div class=&quot;wrapper overHid&quot;&gt; &lt;div class=&quot;big-box&quot;&gt;non-float&lt;/div&gt; &lt;div class=&quot;middle-box green floatL&quot;&gt;float left&lt;/div&gt; &lt;div class=&quot;middle-box red&quot;&gt;non-clear&lt;/div&gt;&lt;/div&gt; 从上面这个修改后的demo中可以看出，红色的块盒在没有清楚浮动的情况下，它的margin-top和蓝色块盒的margin-bottom产生了折叠，这证明了我上面的结论。 下面我们来谈谈 ‘clearance’ 这个神奇的东西，当浮动元素之后的元素设置clear以闭合相关方向的浮动时，根据w3c规范规定，闭合浮动的元素会在其margin-top以上产生一定的空隙（clearance，如下图），该空隙会阻止元素margin-top的折叠，并作为间距存在于元素的margin-top的上方。关于这个间距的计算稍微有点复杂，但实际工作中你并不需要去计算它，我们先来看看例子吧： 12345&lt;div class=&quot;wrapper overHid&quot;&gt; &lt;div class=&quot;big-box&quot; style=&quot;box-shadow:0 20px 0 rgba(0,0,255,0.2);&quot;&gt;non-float&lt;/div&gt; &lt;div class=&quot;middle-box green floatL&quot; style=&quot;opacity:0.6&quot;&gt;float left&lt;/div&gt; &lt;div class=&quot;middle-box red clear&quot; style=&quot;margin-top:40px;box-shadow:0 -40px 0 rgba(255,0,0,0.2);&quot;&gt;clear&lt;/div&gt;&lt;/div&gt; 上面的图中我们可以看到，我们为红色块盒设置的40px的margin-top（这里我们通过相同高度的阴影来将其可视化）好像并没有对紫色块盒起作用，而且无论我们怎么修改这个margin-top值都不会影响红色块盒的位置，而只由绿色块盒的margin-bottom所决定。 也就是说，我们只需要知道，闭合浮动的元素的border-top会紧贴着相应的浮动元素的margin-bottom。 原来，通过w3c的官方规范可知，闭合浮动的块盒在margin-top上所产生的间距（clearance）的值与该块盒的margin-top之和应该足够让该块盒垂直的跨越浮动元素的margin-bottom，使闭合浮动的块盒的border-top恰好与浮动元素的块盒的margin-bottom相邻接。 用上图例子中的相关值可以得出这样一个式子：r-margin-top + r-clearance = g-margin-top + g-height + g-margin-bottom PS！闭合浮动并不能使浮动元素回到原来的BFC当中！ 分析二：inline-block元素与其兄弟元素、子元素和父元素的外边距都不会折叠（包括其父元素和子元素）inline-block不符合w3c规范所说元素必须是块级盒子的条件，因为规范中又说明，块级盒子的display属性必须是以下三种之一：’block’， ‘list-item’， 和 ‘table’。 原文: http://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html © w3cplus.com]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>BFC</tag>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 初解]]></title>
    <url>%2FMyBlogs%2F2015%2F05%2F19%2FHTML5%E5%88%9D%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是HTML5 万维网的核心语言、标准通用标记语言下的一个应用超文本标记语言（HTML）的第五次重大修改 设计目的 HTML5的设计目的是为了在移动设备上支持多媒体。 新的语法特征被引进以支持这一点，如video、audio和canvas 标记。 HTML5还引进了新的功能，可以真正改变用户与文档的交互方式。 同时使代码更加的语义化 PS：也就是说在以前的HTML并不会支持不同的媒体设备，而HTML5的设计目的就是这个。 HTML5的优点及缺点优点 提高可用性和改进用户的友好体验； 有几个新的标签，这将有助于开发人员定义重要的内容； 可以给站点带来更多的多媒体元素(视频和音频)； 可以很好的替代FLASH和Silverlight； 当涉及到网站的抓取和索引的时候，对于SEO很友好； 将被大量应用于移动应用程序和游戏； 可移植性好。 缺点 浏览器的兼容，因浏览器的兼容造成了用户体验不佳。 发展趋势 HTML5规范开发完成时，将成为主流。 未来可能的趋势 移动优先 游戏开发者领衔“主演” 总结 HTML5的出现实现了HTML自己的自适应设计 同时新增了很多标签，都是特别的强大，如：&lt;video&gt; 新增了许多事件属性 当然HTML到HTML5之间还有一个版本XHTML（w3c关于XHTML的文档:http://w3school.com.cn/xhtml/index.asp）]]></content>
      <categories>
        <category>学习小结</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 响应式布局]]></title>
    <url>%2FMyBlogs%2F2015%2F05%2F12%2FHTML%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[什么是响应式布局 什么是响应式 Web 设计？ RWD 指的是响应式 Web 设计（Responsive Web Design） RWD 能够以可变尺寸传递网页 RWD 对于平板和移动设备是必需的 PS：响应式布局是为了让自己的页面适应不同的设备，如：手机，ipad，电脑之类的设备。体现在不同的设备视口大小不同的页面设计。 BootStrap BootStrap是一个css样式库 这是专门为了响应式布局而设计的样式库 详情请去BootStrap官网查询: http://v3.bootcss.com/ 小结 随着时代的发展手机的普及，作为开发设计的前端，为了更好的与用户的交互，从最初的电脑逐渐的转向到移动设备。 为了网页适应不同的设备（也就是不同的视口大小），出现了响应式设计。 关于HTML的总结 HTML是超文本标记语言 由书写标签代码来设计网页 遇到的困难：最初的就是块的概念，以及每个标签的用处。 HTML的学习基础就先到这了，接下来学习HTML5新增的标签和属性。（加油）]]></content>
      <categories>
        <category>学习小结</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 初解（表格，列表，块）]]></title>
    <url>%2FMyBlogs%2F2015%2F04%2F29%2FHTML%E5%88%9D%E8%A7%A32%2F</url>
    <content type="text"><![CDATA[HTML表格，列表，块 列表的写法 表格的写法 块的概念和运用 HTML表格定义表格 使用 &lt;table&gt; 标签来定义 每个表格均有若干行（由 &lt;tr&gt; 标签定义） 每行被分割为若干单元格（由 &lt;td&gt; 标签定义） 字母 td 指表格数据（table data），即数据单元格的内容。 数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。 &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; PS：table也有默认属性，如：border设置表格的边框，注意td是被tr所包裹，也就是说先有行，再有列。 表格的标准形式&lt;table&gt; &lt;thead&gt; &lt;th&gt; &lt;td&gt;表格页眉的表头&lt;/td&gt; &lt;td&gt;表格页眉中的内容&lt;/td&gt; &lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表格内容1&lt;/td&gt; &lt;td&gt;表格内容2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;表格的脚步内容1&lt;/td&gt; &lt;td&gt;表格的脚步内容2&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; PS：表格中table属性设置Cellpadding和Cellspacing属性作用 Cellpadding控制单元格内容与其边框之间的空白 Cellspacing设置单元格之间的距离 列表 html中的列表分为两种：有序列表和无序列表以及自定义列表 有序列表 无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。 无序列表始于 &lt;ul&gt; 标签。每个列表项始于 &lt;li&gt; 标签。 &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt; PS：列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。 有序列表 同样，有序列表也是一列项目，列表项目使用数字进行标记。 有序列表始于 &lt;ol&gt; 标签。每个列表项始于 &lt;li&gt; 标签。 &lt;ol&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ol&gt; PS：列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。 自定义列表 自定义列表不仅仅是一列项目，而是项目及其注释的组合。 自定义列表以 &lt;dl&gt; 标签开始。每个自定义列表项以 &lt;dt&gt; 开始。每个自定义列表项的定义以 &lt;dd&gt; 开始。 &lt;dl&gt; &lt;dt&gt;Coffee&lt;/dt&gt; &lt;dd&gt;Black hot drink&lt;/dd&gt; &lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;White cold drink&lt;/dd&gt; &lt;/dl&gt; PS：列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。 自定义列表写法规范：一个dt为标题可以对多个dd，但是一dd不能对多个dt。 块 大多数 HTML 元素被定义为块级元素或内联元素。 “块级元素”译为 block level element，“内联元素”译为 inline element。 HTML 块元素-块级元素在浏览器显示时，通常会以新行来开始（和结束）。例子：&lt;h1&gt;, &lt;p&gt;,&lt;ul&gt;, &lt;table&gt; HTML 内联元素 内联元素在显示时通常不会以新行开始。例子：&lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt; HTML div 元素 PS：及其重要的一个标签，通过div标签和css样式来作为整个网页的布局 HTML &lt;div&gt; 元素是块级元素，它是可用于组合其他 HTML 元素的容器。 &lt;div&gt; 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。 如果与 CSS 一同使用，&lt;div&gt; 元素可用于对大的内容块设置样式属性。 &lt;div&gt; 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 &lt;table&gt; 元素进行文档布局不是表格的正确用法。&lt;table&gt; 元素的作用是显示表格化的数据。 HTML span 元素 PS：&lt;span&gt; 标签用于包裹文字，联合css使用控制字体样式 HTML &lt;span&gt; 元素是内联元素，可用作文本的容器。 &lt;span&gt; 元素也没有特定的含义。 当与 CSS 一同使用时，&lt;span&gt; 元素可用于为部分文本设置样式属性。 总结 所有的html元素可以分为内联元素和块级元素 块级元素都是独占一行 表格和列表都是展示数据的 div加上css很重要，后期两者一起使用，做到页面布局和排版]]></content>
      <categories>
        <category>学习小结</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 初解]]></title>
    <url>%2FMyBlogs%2F2015%2F04%2F25%2FHTML%E5%88%9D%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[HTMLHTML是什么 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 通俗易懂的话就是：HTML不是编程语言，使用标记来描述（展示）网页的标记语言。（PS：网页专用啦） HTML基础HTML标签 标签也称之为标记，通常称为HTML标签 HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt; HTML 标签通常是成对出现的，比如 &lt;b&gt; 和 &lt;/b&gt;；还有一些单标签，比如 &lt;input /&gt; 和 &lt;img /&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 PS：HTML中标题很重要，是SEO做优化的地方，所以很重要，当然不仅仅因为SEO做优化就很重要啦，嗯，就是很重要。（0.-） 标题标签&lt;h1~h6&gt; &lt;/h1~h6&gt; &lt;h1&gt;我是标题一&lt;/h1&gt; &lt;h2&gt;我是标题二&lt;/h2&gt; &lt;h3&gt;我是标题三&lt;/h3&gt; &lt;h4&gt;我是标题四&lt;/h4&gt; &lt;h5&gt;我是标题五&lt;/h5&gt; &lt;h6&gt;我是标题六&lt;/h6&gt; explain:标题标签一般用于包裹标题文本，并设置有默认属性（加粗，不同的字号，独占一行）。 PS：HTML提供的标题标签总共有6个，从1开始到6结束，并且字号是从大到小 段落标签&lt;p&gt; &lt;/p&gt; &lt;p&gt;我是第一个段落&lt;/p&gt; &lt;p&gt;我是第二个段落&lt;/p&gt; explain：段落标签一般用于包裹内容文本，默认字体大小为浏览器字体大小，同样独占一行。 链接&lt;a href=””&gt; &lt;/a&gt; &lt;a href=&quot;www.baidu.com&quot;&gt;点我进入百度&lt;/a&gt; explain：链接标签用于包裹想定义跳转的文字和图片，默认属性href，值是你想跳转的url地址。 图像&lt;img src=”” alt=”” /&gt; &lt;img src=&quot;https://avatars0.githubusercontent.com/u/26076529?v=3&amp;u=02e97315a3c8b1fe9022529b1d0863f1129b1bed&amp;s=400&quot; alt=&quot;就是想让你看我头像&quot; /&gt; explain: 图像标签用于在网页中展示图片的标签，默认属性src用于加载图片地址，alt用于图像的描述。 PS：alt属性是SEO（搜索引擎优化）优化的地方 加粗&lt;b&gt; &lt;/b&gt;,&lt;strong&gt; &lt;/strong&gt; &lt;b&gt;我是加粗的文字&lt;/b&gt; &lt;strong&gt;同上&lt;/shtong&gt; explain: 这两个标签直接将文本包裹，会在页面上出现加粗的字体效果。 PS：当标签不够用时，可消除它的默认属性，用作于容器来使用。 倾斜&lt;i&gt; &lt;/i&gt;,&lt;em&gt; &lt;/em&gt; &lt;i&gt;我倾斜啦&lt;/i&gt; &lt;em&gt;好巧哦我也是&lt;/em&gt; explain: 这两个标签将文本包裹，会在页面上出现倾斜的文字效果。 PS：当标签不够用时，可消除它的默认属性，用作于容器来使用。 换行&lt;br /&gt; explain: 这是一个单标签，用于换行。 div&lt;div&gt; &lt;/div&gt; explain: 这个标签为一个容器，没有任何默认属性，配合css使用，来为自己的页面布局。 PS：这也被称为盒子模型 表单&lt;form&gt; &lt;/form&gt;,&lt;input /&gt;,&lt;select&gt; &lt;option&gt; &lt;/option&gt; &lt;/select&gt; &lt;form&gt; 我是一个可输入的文本框&lt;input type=&quot;text&quot; /&gt; 我是一个按钮&lt;input type=&quot;button&quot; /&gt; 我是一个提交按钮&lt;input type=&quot;submit&quot; /&gt; &lt;/form&gt; explain: form标签是一个简单的，可以与用户交互的，将用户输入的数据传输给后台的一个标签，是表单最外层标签。input标签是表单中的插件，默认的type属性为text，用户可在其中输入文本信息，select是下拉菜单最外层标签，默认属性name为设置下拉菜单的名称，option为下拉菜单中的分类，用于包裹分类内容。 PS：input常用的type属性值： text; (用于输入文本) password; (用于输入密码) button; (按钮) submit; (提交按钮) checkbox; (复选框) radio; (单选框) PS：在定义单选框的时候需将他们name属性设置为一样的值 reset; (重置按钮) 标签小结 标签分为单标签和双标签 双标签必须有结束标签，如：&lt;/&gt; 为了规范书写和不必要的BUG，在单标签后面也要加上 / ，如：&lt;input /&gt; 元素explain: HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。 元素语法 HTML 元素以开始标签起始 HTML 元素以结束标签终止 元素的内容是开始标签与结束标签之间的内容 某些 HTML 元素具有空内容（empty content） 空元素在开始标签中进行关闭（以开始标签的结束而结束） 大多数 HTML 元素可拥有属性 嵌套的 HTML 元素大多数 HTML 元素可以嵌套（可以包含其他 HTML 元素）。HTML 文档由嵌套的 HTML 元素构成。 &lt;html&gt; &lt;body&gt; &lt;p&gt;This is my first paragraph.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 上面的例子 html 标签中包含三个 HTML 元素(html , body , p)。 HTML 实例解释p 元素：&lt;p&gt;This is my first paragraph.&lt;/p&gt; 这个 &lt;p&gt; 元素定义了 HTML 文档中的一个段落。 这个元素拥有一个开始标签 &lt;p&gt;，以及一个结束标签 &lt;/p&gt;。 元素内容是：This is my first paragraph。 body 元素：&lt;body&gt; &lt;p&gt;This is my first paragraph.&lt;/p&gt; &lt;/body&gt; &lt;body&gt; 元素定义了 HTML 文档的主体。 这个元素拥有一个开始标签 &lt;body&gt;，以及一个结束标签 &lt;/body&gt;。 元素内容是另一个 HTML 元素（p 元素）。 html 元素：&lt;html&gt; &lt;body&gt; &lt;p&gt;This is my first paragraph.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; &lt;html&gt; 元素定义了整个 HTML 文档。 这个元素拥有一个开始标签 &lt;html&gt;，以及一个结束标签 &lt;/html&gt;。 元素内容是另一个 HTML 元素（body 元素）。 小结 简而言之，元素就是放在开始标签和结束标签的代码 学习小结 html是超文本标记语言 标签都有默认属性 标签有双标签和单标签 都有结束符号：/ 开始标签和结束标签之间的代码为元素 自我总结第一次写自己的博客，正式成为一只前端的小程序猿啦，感觉自己有点小兴奋啊。知识点有自己的，也有w3school的。我只是搬过来用用啦，别介！（-.0）。附w3school地址：http://www.w3school.com.cn]]></content>
      <categories>
        <category>学习小结</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FMyBlogs%2F2015%2F04%2F21%2FHello-World%2F</url>
    <content type="text"><![CDATA[Hello World##我的hexo第一天]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>